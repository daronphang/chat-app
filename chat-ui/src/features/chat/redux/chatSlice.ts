import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Channel, Message, UnreadChannelHash } from './chat.interface';

interface ChatState {
  channels: Channel[];
  curChannelId: string;
  unreadChannels: UnreadChannelHash;
  // When a chat is loaded, latest metadata for channels/users will be fetched.
  // However, there may be older events in the user's queue which should
  // not overwrite. This serves as a checkpoint for events coming from the queue.
  initTimestamp: string;
}

const initialState: ChatState = {
  curChannelId: '',
  unreadChannels: {},
  channels: [],
  initTimestamp: '',
};

const isNewerEvent = (newEventTimestamp: string, initTimestamp: string): boolean => {
  if (new Date(newEventTimestamp).getTime() > new Date(initTimestamp).getTime()) {
    return true;
  }
  return false;
};

const isSameMessage = (newMsg: Message, curMsg: Message): boolean => {
  if (newMsg.messageId === curMsg.messageId) {
    return true;
  } else if (new Date(newMsg.createdAt).getTime() === new Date(curMsg.createdAt).getTime()) {
    // Message id is generated by the server and by client side.
    // For new messages sent by sender, this is the only property to use for comparison.
    return true;
  }
  return false;
};

const isNewerMessage = (newMsg: Message, curMsg: Message): boolean => {
  // If the response received is too fast, using updatedTimestamp may be unreliable.
  if (newMsg.messageStatus > curMsg.messageStatus) return true;
  return false;
};

const isMessageBigger = (newMsg: Message, curMsg: Message): boolean => {
  if (newMsg.messageId && curMsg.messageId && newMsg.messageId > curMsg.messageId) {
    return true;
  } else if (new Date(newMsg.createdAt).getTime() > new Date(curMsg.createdAt).getTime()) {
    return true;
  }
  return false;
};

const getLatestTimestamp = (channel: Channel): number => {
  if (channel.messages.length === 0) {
    return new Date(channel.createdAt).getTime();
  }
  return new Date(channel.messages[channel.messages.length - 1].createdAt).getTime();
};

const sortChannelsByLatestTimestamp = (channels: Channel[]) => {
  // When new messages or channels are created, the channels need to be sorted
  // in descending order. This operation will not be costly as only 1 channel may
  // need to be spliced to the front of an already sorted array.
  // Hence, it is ok to call this function whenever there is a change in channels.
  channels.sort((a, b) => {
    return getLatestTimestamp(b) - getLatestTimestamp(a);
  });
};

export const chatSlice = createSlice({
  name: 'chat',
  initialState,
  // Redux doesn't allow updates to action.payload as the same object might be
  // used in other dispatches.
  reducers: {
    resetChat: state => {
      state.channels = [];
      state.curChannelId = '';
      state.unreadChannels = {};
      state.initTimestamp = '';
      return state;
    },
    setCurChannelId: (state, action: PayloadAction<string>) => {
      state.curChannelId = action.payload;
      return state;
    },
    addUnreadChannel: (state, action: PayloadAction<string>) => {
      state.unreadChannels[action.payload] = true;
      return state;
    },
    setChannelAsRead: (state, action: PayloadAction<string>) => {
      if (action.payload in state.unreadChannels) {
        delete state.unreadChannels[action.payload];
      }
      return state;
    },
    initChannels: (state, action: PayloadAction<Channel[]>) => {
      sortChannelsByLatestTimestamp(action.payload);
      state.channels = action.payload;
      state.initTimestamp = new Date().toISOString();
      return state;
    },
    addMessage: (state, action: PayloadAction<Message>) => {
      // Multiple state updates required.
      if (isNewerEvent(state.initTimestamp, action.payload.updatedAt)) {
        return state;
      }

      const v = action.payload;
      const channel = state.channels.find(row => row.channelId === v.channelId);

      if (!channel) {
        // Channel does not exist, to add.
        const newChannel: Channel = {
          channelId: v.channelId,
          channelName: '',
          userIds: [v.senderId],
          messages: [v],
          createdAt: v.createdAt,
          updatedAt: v.createdAt,
          lastMessageId: 0,
        };
        state.channels.push(newChannel);
        sortChannelsByLatestTimestamp(state.channels);
        return state;
      }

      // Message received may not come in sequential order.
      // Need to check for deduplicated messages also.
      const size = channel.messages.length;
      let curMsg: Message;

      if (size === 0 || isMessageBigger(v, channel.messages[size - 1])) {
        channel.messages.push(action.payload);
        sortChannelsByLatestTimestamp(state.channels);
        return state;
      }

      // Handle deduplication of messages or older messages that have not been added
      // due to network/processing delays.
      for (let i = size - 1; i >= 0; i--) {
        curMsg = channel.messages[i];
        if (isSameMessage(v, curMsg)) {
          if (isNewerMessage(v, curMsg) || isNewerEvent(v.updatedAt, curMsg.updatedAt)) {
            curMsg.messageId = v.messageId;
            curMsg.messageStatus = v.messageStatus;
            curMsg.updatedAt = v.updatedAt;
          }
          return state;
        } else if (isMessageBigger(v, curMsg)) {
          // Older message.
          channel.messages.splice(i + 1, 0, v);
          return state;
        }
      }

      // Message received is the oldest.
      channel.messages.unshift(v);
      return state;
    },
    addChannel: (state, action: PayloadAction<Channel>) => {
      // Multiple state updates required.
      if (isNewerEvent(state.initTimestamp, action.payload.updatedAt)) {
        return state;
      }

      const v = action.payload;
      const channel = state.channels.find(row => row.channelId === v.channelId);

      if (!channel) {
        const newChannel: Channel = {
          ...v,
          messages: [],
          lastMessageId: 0,
        };
        state.channels.push(newChannel);
        sortChannelsByLatestTimestamp(state.channels);
        return state;
      } else if (!isNewerEvent(v.updatedAt, channel.updatedAt)) {
        return state;
      }

      // Update existing channel metadata.
      channel.channelName = v.channelName;
      channel.userIds = v.userIds;
      if (v.lastMessageId > channel.lastMessageId) {
        channel.lastMessageId = v.lastMessageId;
      }
      return state;
    },
    moveChannelToFront: (state, action: PayloadAction<string>) => {
      const idx = state.channels.findIndex(row => row.channelId === action.payload);
      if (idx === -1) {
        return state;
      }
      const channel = state.channels.splice(idx, 1)[0];
      state.channels.splice(0, 0, channel);
      return state;
    },
    setLastReadMessageInChannel: (state, action: PayloadAction<string>) => {
      const channel = state.channels.find(row => row.channelId === action.payload);
      if (!channel) {
        return state;
      }

      const latestMessageId = channel.messages[channel.messages.length - 1].messageId;
      channel.lastMessageId = latestMessageId;
      return state;
    },
    addOlderMessages: (state, action: PayloadAction<Message[]>) => {
      if (action.payload.length === 0) {
        return state;
      }

      const chId = action.payload[0].channelId;
      const channel = state.channels.find(row => row.channelId === chId);
      if (!channel) {
        return state;
      }

      if (isNewerEvent(action.payload[action.payload.length - 1].createdAt, channel.messages[0].createdAt)) {
        return state;
      }

      channel.messages = [...action.payload, ...channel.messages];
      return state;
    },
  },
});

export const {
  resetChat,
  initChannels,
  addChannel,
  moveChannelToFront,
  addMessage,
  setCurChannelId,
  addUnreadChannel,
  setChannelAsRead,
  setLastReadMessageInChannel,
  addOlderMessages,
} = chatSlice.actions;
export default chatSlice.reducer;
