import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { Channel, Message, MessageStatus } from './chat.interface';
import { Friend } from 'features/user/redux/user.interface';

interface UnreadChannelHash {
  [key: string]: boolean;
}

interface ChannelHash {
  [key: string]: Channel;
}

interface ChatState {
  channelHash: ChannelHash;
  curChannelId: string;
  unreadChannels: UnreadChannelHash;
}

const initialState: ChatState = {
  curChannelId: '',
  unreadChannels: {},
  channelHash: {},
};

const isNewerEvent = (newEventTimestamp: string, curEventTimestamp: string): boolean => {
  if (new Date(newEventTimestamp).getTime() > new Date(curEventTimestamp).getTime()) {
    return true;
  }
  return false;
};

const isSameMessage = (newMsg: Message, curMsg: Message): boolean => {
  if (newMsg.messageId === curMsg.messageId) {
    return true;
  } else if (new Date(newMsg.createdAt).getTime() === new Date(curMsg.createdAt).getTime()) {
    // Message id is generated by the server and by client side.
    // For new messages sent by sender, this is the only property to use for comparison.
    return true;
  }
  return false;
};

const isMessageBigger = (newMsg: Message, curMsg: Message): boolean => {
  if (newMsg.messageId && curMsg.messageId && newMsg.messageId > curMsg.messageId) {
    return true;
  } else if (new Date(newMsg.createdAt).getTime() > new Date(curMsg.createdAt).getTime()) {
    return true;
  }
  return false;
};

export const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    setCurChannelId: (state, action: PayloadAction<string>) => {
      state.curChannelId = action.payload;
      return state;
    },
    addUnreadChannel: (state, action: PayloadAction<string>) => {
      state.unreadChannels[action.payload] = true;
      return state;
    },
    setChannelAsRead: (state, action: PayloadAction<string>) => {
      if (action.payload in state.unreadChannels) {
        delete state.unreadChannels[action.payload];
      }
      return state;
    },
    initChannels: (state, action: PayloadAction<Channel[]>) => {
      action.payload.forEach(row => {
        state.channelHash[row.channelId] = row;
      });
      return state;
    },
    addMessage: (state, action: PayloadAction<Message>) => {
      // Multiple state updates required.
      const v = action.payload;
      if (!(v.channelId in state.channelHash)) {
        // Channel does not exist, to add.
        const newChannel: Channel = {
          channelId: v.channelId,
          channelName: '',
          userIds: [v.senderId],
          messages: [v],
          createdAt: v.createdAt,
          updatedAt: v.createdAt,
          lastMessageId: 0,
        };
        state.channelHash[v.channelId] = newChannel;
        return state;
      }

      // Message received may not come in sequential order.
      // Need to check for deduplicated messages also.
      const channel = state.channelHash[v.channelId];
      const size = channel.messages.length;
      let curMsg: Message;

      if (size === 0 || isMessageBigger(v, channel.messages[size - 1])) {
        channel.messages.push(action.payload);
        return state;
      }

      // Handle deduplication of messages or older messages that have not been added
      // due to network/processing delays.
      for (let i = size - 1; i >= 0; i--) {
        curMsg = channel.messages[i];
        if (isSameMessage(v, curMsg)) {
          if (isNewerEvent(v.updatedAt, curMsg.updatedAt)) {
            curMsg.messageId = v.messageId;
            curMsg.messageStatus = v.messageStatus;
          }
          return state;
        } else if (isMessageBigger(v, curMsg)) {
          // Older message.
          channel.messages.splice(i + 1, 0, v);
          return state;
        }
      }

      // Message received is the oldest.
      channel.messages.unshift(v);
      return state;
    },
    addChannel: (state, action: PayloadAction<Channel>) => {
      // Multiple state updates required.
      const v = action.payload;
      if (!(v.channelId in state.channelHash)) {
        state.channelHash[v.channelId] = v;
        return state;
      }

      // Update existing channel if applicable.
      const curChannel = state.channelHash[v.channelId];
      if (!isNewerEvent(v.updatedAt, curChannel.updatedAt)) {
        return state;
      }

      curChannel.channelId = v.channelId;
      curChannel.channelName = v.channelName;
      curChannel.createdAt = v.createdAt;
      if (v.isDraft) {
        curChannel.isDraft = v.isDraft;
      }

      return state;
    },
    setMessageAsRead: (state, action: PayloadAction<Message>) => {
      // Redux doesn't allow updates to action.payload as the same object might be
      // used in other dispatches.
      if (!(action.payload.channelId in state.channelHash)) {
        return state;
      }

      const channel = state.channelHash[action.payload.channelId];
      let cur: Message;
      for (let i = channel.messages.length - 1; i >= 0; i--) {
        cur = channel.messages[i];
        if (cur.messageId === action.payload.messageId) {
          cur.messageStatus = MessageStatus.READ;
          return state;
        }
      }

      return state;
    },
    setLastReadMessageId: (state, action: PayloadAction<string>) => {
      if (!(action.payload in state.channelHash)) {
        return state;
      }
      const channel = state.channelHash[action.payload];
      const latestMessageId = channel.messages[channel.messages.length - 1].messageId;
      channel.lastMessageId = latestMessageId;
      return state;
    },
    addOlderMessages: (state, action: PayloadAction<Message[]>) => {
      if (action.payload.length === 0) {
        return state;
      }

      const chId = action.payload[0].channelId;
      if (!(chId in state.channelHash)) {
        return state;
      }
      const channel = state.channelHash[chId];
      channel.messages = [...action.payload, ...channel.messages];
      return state;
    },
  },
});

export const {
  initChannels,
  addChannel,
  addMessage,
  setCurChannelId,
  addUnreadChannel,
  setChannelAsRead,
  setLastReadMessageId,
  addOlderMessages,
} = chatSlice.actions;
export default chatSlice.reducer;
