import { createSlice, Draft, PayloadAction } from '@reduxjs/toolkit';

// 1 = sending, 2 = sent, 3 = delivered
export type MessageStatus = 'pending' | 'received' | 'delivered' | 'read';

export interface Message {
  messageId: number;
  channelId: string;
  senderId: string;
  messageType: string;
  content: string;
  createdAt: string;
  messageStatus: MessageStatus;
}

export interface Channel {
  channelId: string;
  channelName: string;
  createdAt: string;
  messages: Message[];
  userIds: string[];
}

interface UnreadChannelHash {
  [key: string]: boolean;
}

interface ChatState {
  channels: Channel[];
  curChannelId: string;
  unreadChannels: UnreadChannelHash;
}

export interface WebSocketEvent {
  event: string;
  data: any;
}

const initialState: ChatState = {
  curChannelId: '',
  unreadChannels: {},
  channels: [],
};

const isSameMessage = (newMsg: Message, cur: Message): boolean => {
  if (newMsg.messageId && cur.messageId && newMsg.messageId === cur.messageId) {
    return true;
  } else if (new Date(newMsg.createdAt).getTime() === new Date(cur.createdAt).getTime()) {
    // Message id is generated by the server and by client side.
    // For new messages sent by sender, this is the only property to use for comparison.
    return true;
  }
  return false;
};

const isNewMessageBigger = (newMsg: Message, cur: Message): boolean => {
  if (newMsg.messageId && cur.messageId && newMsg.messageId > cur.messageId) {
    return true;
  } else if (new Date(newMsg.createdAt).getTime() > new Date(cur.createdAt).getTime()) {
    return true;
  }
  return false;
};

export const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    setCurChannelId: (state, action: PayloadAction<string>) => {
      state.curChannelId = action.payload;
      return state;
    },
    addUnreadChannel: (state, action: PayloadAction<string>) => {
      state.unreadChannels[action.payload] = true;
      return state;
    },
    removeReadChannel: (state, action: PayloadAction<string>) => {
      delete state.unreadChannels[action.payload];
      return state;
    },
    addNewChannel: (state, action: PayloadAction<Channel>) => {
      // Redux doesn't allow mutation of action.payload as this mutation
      // could leak out into any other reducers listening for the same action.
      state.channels.push(action.payload);
      return state;
    },
    initChannels: (state, action: PayloadAction<Channel[]>) => {
      // Sort by latest timestamp.
      action.payload.sort((a, b) => {
        let ts1: Date;
        let ts2: Date;

        if (a.messages.length === 0) {
          ts1 = new Date(a.createdAt);
        } else {
          ts1 = new Date(a.messages[a.messages.length - 1].createdAt);
        }

        if (b.messages.length === 0) {
          ts2 = new Date(b.createdAt);
        } else {
          ts2 = new Date(b.messages[b.messages.length - 1].createdAt);
        }
        return ts2.getTime() - ts1.getTime();
      });
      state.channels = action.payload;
      return state;
    },
    addNewMessage: (state, action: PayloadAction<Message>) => {
      // Multiple state updates required.
      // Channel must first be added if it does not exist.
      const idx = state.channels.findIndex(row => row.channelId === action.payload.channelId);
      if (idx === -1) {
        return state;
      }

      const channel = state.channels[idx];

      // Message received may not come in sequential order.
      const size = channel.messages.length;
      if (size === 0 || isNewMessageBigger(action.payload, channel.messages[size - 1])) {
        channel.messages.push(action.payload);
        return state;
      }

      for (let i = size - 1; i >= 0; i--) {
        const curMsg = channel.messages[i];
        if (isSameMessage(action.payload, curMsg)) {
          curMsg.messageId = action.payload.messageId;
          curMsg.messageStatus = action.payload.messageStatus;
          return state;
        } else if (isNewMessageBigger(action.payload, curMsg)) {
          channel.messages.splice(i + 1, 0, action.payload);
          return state;
        }
      }

      channel.messages.unshift(action.payload);
      return state;
    },
    updateChannel: (state, action: PayloadAction<Channel>) => {
      // Multiple state updates required.
      const idx = state.channels.findIndex(row => row.channelId === action.payload.channelId);
      if (idx === -1) {
        return state;
      }

      const channel = state.channels[idx];
      channel.channelId = action.payload.channelId;
      channel.channelName = action.payload.channelName;
      channel.createdAt = action.payload.createdAt;

      // Move to front.
      state.channels.splice(idx, 1);
      state.channels.push(channel);
      return state;
    },
  },
});

export const {
  addNewChannel,
  initChannels,
  updateChannel,
  addNewMessage,
  setCurChannelId,
  addUnreadChannel,
  removeReadChannel,
} = chatSlice.actions;
export default chatSlice.reducer;
